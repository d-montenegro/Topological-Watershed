Representacion de imagenes:

  *) La forma usual es con un arreglo bla bla bla
  *) La otra forma es topologica bla bla blablabla
  *) La otra forma es como un grafo con pesos bla bla bla En lo que respecta al
procesamiento de imágenes, podemos pensar que E ⊆ Z^2, Γ
representará la relación de adyacencia entre los píxeles, y F el nivel de gris
de cada pixel.





4. Watershed Topológico cuasi-lineal

En [1] se propone  un algoritmo  de orden cuasi-lineal para el cálculo del
Watershed Topológio de una imagen. Se logra esta notable diferencia de
eficiencia con respecto al anterior a partir de dos factores. Por un lado, los
pixeles se procesan  de tal modo de asegurar que su valor se reducirá sólo una
vez durante la ejecutó del algritmo.
Por el otro, se dismunye el valor de un pixel W-destructible no en 1, si no en
el máximo valor posible. Esto se logra gracias a una estructura de datos llamada
Árbol de Componentes que explicaremos a continuación.

En este capítulo primero repasaremos algunas nociones útiles de grafos, luego
explicaremos el Árbol de Componentes. Después explicaremos que rol del árbol de
ocmponentes y finalmente explicaremos como se implementa el algoritmo.

4.1. Nociones previas

Para un repaso de grafos, ver anexo 1.

Sea (E,Γ,F) un grafo con pesos. Denotamos con Kmin = min{ F(p) : p ∈ E }, Kmax
= max{ F(p) : p ∈ E }. Sea k : Kmin <= k <= Kmax.
  *) Llamamos sección de nivel k, o k-sección a F[k] = { p ∈ E : F(p) >= k }.
  *) Llamamos k-componente (o simplemente componente) de F a una componente
conectada de F[k].
  *) Una componente m de F será un mínimo de F si no hay otra componente de F
incluida en m.
  *) Definimos Ck(F) como el conjunto de todas las k-componentes de F
  *) Definimos Γ-(p) = { q ∈ Γ(p) : F(q) < F(p) }

<ejemplo, imagen>

  
4.2. Árbol de Componentes

<Acá puede venir una referencia de esto, que aplicaciones tiene, etc>

4.2.1. Definión

Para entender de un modo intuitivo qué es el árbol de componentes de una
imgen, tenemos que imaginarla como un relive topográfico (ver sección
2.1) completamente sumergida en agua, a la que se le hacen perforaciones en sus
mínimos. El nivel de agua irá decreciendo lentamente, y empezarán a verse islas
(correspondientes a los máximos de la imagen), estas islas serán las hojas del
árbol. A medida que el nivel de agua continue decreciendo, las islas irán
creciendo, conformando lo que serán las ramas del árbol. Luego, a partir de
algún nivel, puede que algunas islas se fusionen formando una sola pieza, estas
piezas serán forks del árbol. El proceso terminará cuando toda el agua haya
desaparecido.

<imagen>

Sea (E,Γ,F) un grafo con pesos. Podemos definir el árbol de componentes T(F)
como un árbol que cumple con estas dos propiedades:
  *) los nodos son elementos de C(F) = Uk=Kmin,Kmax Ck(F).
  *) habrá un arco de c' ∈ Ck(F) hacia la componente c ∈ Cj(F) si j = k+1 y c ⊆
c'

En este caso, se dice que c es hijo de c' y que c' es padre de c. Además, las
componentes que no tiene hijos, se denominan hojas, mientras que las que no
tienen padre, raíces.

Junto al árbol de componentes, tendremeos también el denominado mapeo de
componentes, que para cada pixel de nivel k de la imagen, asociará la
componente que contiene a p en Ck(F).

4.2.2. Ejemplos

<Acá pueden venir un par de imágenes que muestren paso a paso cómo se calcula>

4.3. Análisis teórico

Sea (E,Γ,F) un grafo con pesos, definimos F complemento[k] = complemento (F[k])
= { p ∈ E : F(p) < k }

Cómo dijimos previamente, el algoritmo que presentaremos a continuación utiliza
el Árbol de componentes de F complemento, al cual representaremos como T(F
complemento). Del mismo modo, un par [k,c] representará un nodo del árbol,
donde c ∈ Ck(F complemento). Llamaremos altura de [k,c] alnúmero k.

Antes de explicar cómo se utiliza C(F complemento), necesitamos introducir las
siguientes definiciones.


  *) Decimos que [k1,c1] es ancestro de [k2,c2] si k2 ≤ k1 y c2 ⊆ c1. En este
caso, también decimos que [k1,c1] está encima de [k2,c2] y que [k2,c2] está
abajo de [k1,c1].

  *) Decimos que [k,c] es ancestro común de [k1,c1],[k2,c2] si [k,c] es ancestro
de [k1,c1] y [k,c] es ancestro de [k2,c2].

  *) Decimos que [k,c] es el menor ancestro comun de [k1,c1],[k2,c2], si [k,c]
es ancestro de comun de ambos y no hay ningún otro ancestro común abajo de
[k,c].

  *) Decimos que [k,c] es el menor ancestro común propio de [k1,c1],[k2,c2] si
[k,c] es ancestro común de ambos y [k,c] es distinto de [k1,c1] y [k,c] es
distinto de [k2,c2].

  *) Decimos que [k1,c1],[k2,c2] están separadas si tienen menor ancestro común
propio, caso contrario decimos que están linkeadas.

  *) Decimos que [k,c] es highest fork de M = {[k1,c1],[k2,c2],......,[kn,cn]}
si las siguientes condiciones se satisfacen:
    *) Si [ki,ci],[kj,cj] están separados entonces el mínimo ancestro común
tiene altura ≤ k.
    *) existe [ki,ci],[kj,cj] elementos separados de M, tal que [k,c] es el
mínimo ancestro común propio de [ki,ci],[kj,cj]. 

En [1] se demuestra un teorema que establece que un punto p será W-destructible
si y sólo si V(p) = {[F complemento(q),C(q)], q ∈ Γ− (p)} != ∅, y en este caso
podemos diferenciar dos escenarios:
  *) V(p) no tiene highest fork en C(F complemento), en este caso el lowest
value de p será w-1, donde w denota el nivel del elemento más pequeño de V(p).
  *) V(p) tiene highest fork en C(F complemento), si la altura de ese highest
fork ≤ F(p), en este caso el lowest value será v-1.


4.4. Implementación

<Acá vendra pseudo código junto a algunas referencias a mi codigo>

<Existe un algoritmo de orden cuasi lineal hecho por bla bla basado que utiliza
una estructura llamada conjuntos disjuntos>

Conjuntos Disjuntos

El problema de los conjuntos disjuntos consiste en mantener una colección Q de
subconjuntos disjuntos, de un conjunto E. Cada conjunto X en Q será
representado por un único elemento de X, llamando elemento canónico. Sean x e
y dos elementos distintos de E, las operaciones que pueden hacerse sobre Q serán
las siguientes:
  *) MakeSet(x): agrega el conjunto {x} a Q.
  *) Find(x): retorna el elemento canónico del conjunto al que pertenece x.
  *) Link(x,y): sean X e Y dos conjuntos de Q con elemento canónico x e y
respectivamente, entonces esta operación borrar ambos conjuntos de Q y agregará
el conjunto Z = X ∪ Y, y retornará el elemento canónico de Z.

Para comprender el papel de estas estructuras en el armado del "Árbol de
Componentes", proporcionamos el siguiente pseudo-código que determina las
componentes conectadas 







Para poder explicar este algoritmo, primero debemos introducir el concepto de
"Árbol de componentes".


<Ejemplos, muchos ejemplos>

Implementación

Acá voy a hacer un diagrama de clases para que quede claro como está
implementado

Conclusión

Acá pongo los resultados, en términos de eficiencia, de correr el algoritmo


Watershed Topológico Paralelo

Este, tendría que estudiarlo bien -> Acá tengo que hacer foco ahora


Lo que podría hacer para explicar el algoritmo es lo siguiente:

Naive Topological Watershed

<Sacar data de las referencias del quasi-lineal>



Anexos:

Bueno, antes de ver el algoritmo de watershed topologico, vamos a pensar que en
una sección previa, o en algún anexo están los siguientes contenidos:
-) Qué es un grafo
-) Como representar una imagen con un grafo con pesos
-) Stacks (downstack y upstack)


*)Topological notions for graphs (va a algun anexo)

Sea E un conjunto finito, entonces con P(E) denotamos el conjunto de todos los
subconjutos de E, y comúnmente se lo denomina "partes de E". Definimos con Γ
una relación binaria en E, es decir, Γ ⊆ E × E, reflexiva (para todo p ∈ E,
(p,p) ∈ Γ) y simétrica (si (p,q) ∈ Γ entonces (q,p) ∈ Γ).

Un grafo G será un par (E,Γ), donde a los elementos de E se los conoce como
vértices, nodos o puntos, y Γ: E -> P(E), donde Γ(p) = {q ∈ E | (p,q) ∈ Γ}. Para
cada punto p, el conjunto Γ(p) es llamado "vecindario"
de p. Si q ∈ Γ(p), decimos que p y q son adjacentes, o que q es vecino de p.
Además, si X ⊆ E y q es adyancente a algun p ⊆ X, entonces se dice que q es
adyacente a X.




Definición 1:

Sea E un conjunto, sea X ⊆ E un sobconjunto y p ∈ X un elemento.
Diremos que p es un border point para X si es adyacente al complemento de X
Diremos que p es un inner point para X si p no es un border point para X
Diremos que p es un separating point para X si p es adyacente a dos o más
componentes conectadas del complemento de X
Diremos que p es W-simple para X si p es adyacente a exactamente una componente
conectada del complemento de X

<Aca vienen conclusiones y ejemplos>

Definición 3: Aca se define:
la componente del complemento de F a nivel k, o k-componente del complemento
de F
el minimo de F
C(p,F complemento)
Γ− (p, F)

<Aca vienen ejemplos>

Definición 4: Se define para una k-seccion
border point
inner point
separating point
W-destrutible point

<Ejemplos>

Definición 5: Acá se define qué es el topological watershed


Anexo 1

Grafo

En este apartado repasaremos algunas nociones básicas de los grafos, dado que
se utilizarán en el desarrollo de este capítulo.

Sea E con conjunto finito, entonces denotamos con P(E) (denominado "partes de
E") el conjunto de todos los subconjuntos de E. Un grafo será un par (E,Γ),
donde Γ : E -> P(E) es una relación entre los elementos de E. A los elementos
de E los denominamos vértices o puntos, mientras que para algún p ∈ E,
llamaremos vencindario de p a cada uno de los elementos de Γ(p).

Sea (E,Γ) un grafo, X ⊆ E, y x0,xn ∈ X. 

  *) Sean x0,xn ∈ X, un camino de x0 hacia xn en X es un conjunto ordenado
(x0,x1,...,xn) de elementos de X, donde xi+1 ∈ Γ(xi) para i = 0,1,...,n-1.
  *) Sean x,y ∈ X, decimos que x e y están conectados en X si existe un camino
de x hacia y en X.
  *) Decimos que X está conectado si cada par de elementos de X están
conectados en X.
  *) Sea Y ⊆ E, Y es una componente conectada de X si Y ⊆ X, Y está conectado y
Y es maximal.

<ejemplo, imagen>

  Un grafo con pesos será terna (E,Γ,F), donde (E,Γ) es un grafo, y F será un
mapa de E -> Z. Si p ∈ E, entonces denominamos F(p) como el peso, o nivel de p.
  
<ejemplo, imagen>


