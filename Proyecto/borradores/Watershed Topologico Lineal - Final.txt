4. Watershed Topológico cuasi-lineal

En [1] se propone  un algoritmo  de orden cuasi-lineal para el cálculo del
Watershed Topológio de una imagen. Se logra esta notable diferencia de
eficiencia con respecto al anterior a partir de dos factores. Por un lado, los
pixeles se procesan de tal modo de asegurar que su valor se reducirá, a lo sumo,
sólo una vez durante la ejecución del algritmo. Por el otro, se dismunye el
valor de un pixel W-destructible no en 1, si no en el máximo valor posible.
Esto último se logra gracias a la utilización de una estructura de datos llamada
Árbol de Componentes, que introduciremos a continuación.

En este capítulo, primero repasaremos algunas nociones de grafos que serán
útiles, luego explicaremos el Árbol de Componentes. Después explicaremos que rol
del árbol de ocmponentes y finalmente explicaremos como se implementa el
algoritmo.

4.1. Nociones previas

Para un repaso de grafos, ver anexo 1.

Sea (E,Γ,F) un grafo con pesos. Denotamos con Kmin = min{ F(p) : p ∈ E }, Kmax
= max{ F(p) : p ∈ E }. Sea k : Kmin <= k <= Kmax.
  *) Llamamos sección de nivel k, o k-sección a F[k] = { p ∈ E : F(p) >= k }.
  *) Llamamos k-componente (o simplemente componente) de F a una componente
conectada de F[k].
  *) Una componente m de F será un mínimo de F si no hay otra componente de F
incluida en m.
  *) Definimos Ck(F) como el conjunto de todas las k-componentes de F
  *) Definimos Γ-(p) = { q ∈ Γ(p) : F(q) < F(p) }

<ejemplo, imagen>

  
4.2. Árbol de Componentes

<Acá puede venir una referencia de esto, que aplicaciones tiene, etc>

4.2.1. Definión

Para entender de un modo intuitivo qué es el árbol de componentes de una
imgen, tenemos que imaginarla como un relive topográfico (ver sección
2.1) completamente sumergida en agua, a la que se le hacen perforaciones en sus
mínimos. El nivel de agua irá decreciendo lentamente, y empezarán a verse islas
(correspondientes a los máximos de la imagen), estas islas serán las hojas del
árbol. A medida que el nivel de agua continue decreciendo, las islas irán
creciendo, conformando lo que serán las ramas del árbol. Luego, a partir de
algún nivel, puede que algunas islas se fusionen formando una sola pieza, estas
piezas serán forks del árbol. El proceso terminará cuando toda el agua haya
desaparecido.

<imagen>

Sea (E,Γ,F) un grafo con pesos. Podemos definir el árbol de componentes T(F)
como un árbol que cumple con estas dos propiedades:
  *) los nodos son elementos de C(F) = Uk=Kmin,Kmax Ck(F).
  *) habrá un arco de c' ∈ Ck(F) hacia la componente c ∈ Cj(F) si j = k+1 y c ⊆
c'

En este caso, se dice que c es hijo de c' y que c' es padre de c. Además, las
componentes que no tiene hijos, se denominan hojas, mientras que las que no
tienen padre, raíces.

Junto al árbol de componentes, tendremeos también el denominado mapeo de
componentes, que para cada pixel de nivel k de la imagen, asociará la
componente que contiene a p en Ck(F).

4.2.2. Ejemplos

<Acá pueden venir un par de imágenes que muestren paso a paso cómo se calcula>

4.3. Análisis teórico

Sea (E,Γ,F) un grafo con pesos, definimos F complemento[k] = complemento (F[k])
= { p ∈ E : F(p) < k }

Cómo dijimos previamente, el algoritmo que presentaremos a continuación utiliza
el Árbol de componentes de F complemento, al cual representaremos como T(F
complemento). Del mismo modo, un par [k,c] representará un nodo del árbol,
donde c ∈ Ck(F complemento). Llamaremos altura de [k,c] alnúmero k.

Antes de explicar cómo se utiliza C(F complemento), necesitamos introducir las
siguientes definiciones.


  *) Decimos que [k1,c1] es ancestro de [k2,c2] si k2 ≤ k1 y c2 ⊆ c1. En este
caso, también decimos que [k1,c1] está encima de [k2,c2] y que [k2,c2] está
abajo de [k1,c1].

  *) Decimos que [k,c] es ancestro común de [k1,c1],[k2,c2] si [k,c] es ancestro
de [k1,c1] y [k,c] es ancestro de [k2,c2].

  *) Decimos que [k,c] es el menor ancestro comun de [k1,c1],[k2,c2], si [k,c]
es ancestro de comun de ambos y no hay ningún otro ancestro común abajo de
[k,c].

  *) Decimos que [k,c] es el menor ancestro común propio de [k1,c1],[k2,c2] si
[k,c] es ancestro común de ambos y [k,c] es distinto de [k1,c1] y [k,c] es
distinto de [k2,c2].

  *) Decimos que [k1,c1],[k2,c2] están separadas si tienen menor ancestro común
propio, caso contrario decimos que están linkeadas.

  *) Decimos que [k,c] es highest fork de M = {[k1,c1],[k2,c2],......,[kn,cn]}
si las siguientes condiciones se satisfacen:
    *) Si [ki,ci],[kj,cj] están separados entonces el mínimo ancestro común
tiene altura ≤ k.
    *) existe [ki,ci],[kj,cj] elementos separados de M, tal que [k,c] es el
mínimo ancestro común propio de [ki,ci],[kj,cj]. 

En [1] se demuestra un teorema que establece que un punto p será W-destructible
si y sólo si V(p) = {[F complemento(q),C(q)], q ∈ Γ− (p)} != ∅, y en este caso
podemos diferenciar dos escenarios:
  *) V(p) no tiene highest fork en C(F complemento), en este caso el lowest
value de p será w-1, donde w denota el nivel del elemento más pequeño de V(p).
  *) V(p) tiene highest fork en C(F complemento), si la altura de ese highest
fork ≤ F(p), en este caso el lowest value será v-1.


4.4. Implementación

<Acá vendra pseudo código junto a algunas referencias a mi codigo>