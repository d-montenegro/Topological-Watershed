\chapter{Watershed Topológico Cuasi-Lineal}

En [1] se propone  un algoritmo  de orden cuasi-lineal para el cálculo del Watershed Topológio de una imagen. Se logra esta notable eficiencia a partir de dos factores. Por un lado, los pixeles se procesan siguiendo un orden de modo de asegurar que su valor se reducirá, a lo sumo, sólo una vez durante toda la ejecución del algoritmo. Por el otro, se dismunye el valor de un pixel W-destructible no en 1, si no en el máximo valor posible. Esto último se logra gracias a la utilización de una estructura de datos llamada "Árbol de Componentes", que será introducida a continuación.

En este capítulo repasaremos en primer lugar algunas definiciones básicas, luego se introducirá el concepto de Árbol de Componentes de una imagen, para después explicar el rol del mismo en el cálculo del Watershed Topológico. Finalmente se dará un pseudo-código junto a una explicación línea a línea, a fin de mostrar el procedimiento detalladamente.

\section{Definiciones preliminares}

En el presente capítulo se utilizará la representación de la imagen como un grafo con pesos, tal como se vio en la sección 2.1. A continuación se presentan conceptos claves.

Sea $(E,\Gamma,F)$ un grafo con pesos, entonces definimos $K_{min} = min\{F(p) : p \in E\}$, $K_{max} = max\{F(p) : p \in E \}$, $K = [K_{min},K_{max}]$. Sea $k \in K, p \in E$, entonces

\begin{itemize}
  \item El conjunto de todos los vecinos de p con peso menor a p se denotará con $\Gamma-(p)$, es decir, $\Gamma-(p) = \{ q \in \Gamma(p) : F(q) < F(p) \}$.
  \item Una $\textbf{k-sección}$ de F será el conjunto $F[k] = \{ p \in E : F(p) \ge k \}$.
  \item Una $\textbf{k-componente}$ (o simplemente componente) de F será una componente conectada de F[k].
  \item Un $\textbf{mínimo}$ de F será una componente m de F que no incluya ninguna otra componente de F.
  \item El conjunto de todas las k-componentes de F se denotará con $C_k(F)$.
  \item El conjunto de todas las componentes de F se denotará C(F), es decir, \[ C(F) = \bigcup_{k=K_{min}}^{K_{max}}{C_k(F)} \]
\end{itemize}

En lo que a procesamiento de imágenes respecta, podemos ver los siguientes ejemplos:

<Acá vendrán algunas imágenes que ilustren los conceptos anteriores>

\section{Árbol de Componentes}

<Acá vienen referencias>

\subsection{Definión}

Imaginemos una imagen como un relive topográfico (ver sección 2.2.) completamente sumergido en agua, al que se le hacen perforaciones en sus mínimos. El nivel de agua irá disminuyendo lentamente, con lo que empezarán a observarse islas (correspondientes a los máximos de la imagen), estas confirmarán las hojas del árbol de componentes de la imagen. A medida que el nivel de agua continue descendiendo, las islas irán creciendo en tamaño, conformando lo que serán las ramas del árbol. Luego, a partir de algún nivel, algunas islas se fusionarán conformando una sola pieza, estas piezas serán forks del árbol. El proceso terminará cuando toda el agua haya desaparecido.

<Acá vendrán algunas imágenes que ilustren los conceptos anteriores>

Sea $(E,\Gamma,F)$ un grafo con pesos, y sean $k,j \in K$. Entonces el $\textbf{Árbol de Componentes}$ T(F) será un árbol cuyos nodos serán elementos de C(F) y habrá una arista de $c' \in C_k(F)$ hacia la componente $c \in C_j(F)$ si j = k+1 y $c \subseteq c'$. En este caso, decimos que c' es padre de c, y también que c es hijo de c'.

El $\textbf{mapeo de componentes}$ será un mapa $\Psi: E \to C(F)$, que relaciona cada $p \in E$ con el nodo de T(F) que lo contiene.

\subsection{Ejemplo}

<Acá viene un ejemplo de una imagen y su arbol, junto con el component mapping>

\section{Algoritmo}

Para calcular el Watershed Topológico de $(E,\Gamma,F)$, vamos a calcular $T(\overline{F})$, donde $\overline{F}[k] = \overline{F[k]} = \{ p \in E : F(p) < k \}$ y $\overline{F}(p)$ = F(p) + 1 \footnote{Esto se desprende del concepto de stacks, para más información ver [1]}.

Vamos a denotar un nodo de $T(\overline{F})$ como un par [k,c] cuando $c \in C_k(\overline{F})$, y llamaremos nivel del nodo al número k.

Sea $(E,\Gamma,F)$ un grafo, y sean $[k,c], [k_1,c_1], [k_2,c_2], .... , [k_n,c_n]$ nodos de $T(\overline{F})$, entonces

\begin{itemize}
  \item $[k_1,c_1]$ es $\textbf{ancestro}$ de $[k_2,c_2]$ si $k2 \le k1$ y $c2 \subseteq c1$. En este caso, también decimos que $[k_1,c_1]$ está encima de $[k_2,c_2]$ y que $[k_2,c_2]$ está abajo de $[k_1,c_1]$.
  \item $[k,c]$ es $\textbf{ancestro común}$ de $[k_1,c_1]$,$[k_2,c_2]$ si [k,c] es ancestro de $[k_1,c_1]$ y [k,c] es ancestro de $[k_2,c_2]$.
  \item $[k,c]$ es el $\textbf{menor ancestro comun}$ de $[k_1,c_1]$,$[k_2,c_2]$, si [k,c] es ancestro de comun de ambos y no hay ningún otro ancestro común abajo de [k,c].
  \item $[k,c]$ es el $\textbf{menor ancestro común propio}$ de $[k_1,c_1]$,$[k_2,c_2]$ si [k,c] es ancestro común de ambos y [k,c] es distinto de $[k_1,c_1]$ y [k,c] es distinto de $[k_2,c_2]$.
  \item $[k_1,c_1]$,$[k_2,c_2]$ están $\textbf{separados}$ si tienen menor ancestro común propio, caso contrario decimos que están linkeados.
  \item $[k,c]$ es $\textbf{highest fork}$ de M = \{$[k_1,c_1]$,$[k_2,c_2]$,......,$[k_n,c_n]$\} si las siguientes condiciones se satisfacen:
  \begin{itemize}
    \item Si $[k_i,c_i]$,$[k_j,c_j]$ están separados entonces el mínimo ancestro común tiene altura $\le$ k.
    \item Existen $[k_i,c_i]$,$[k_j,c_j]$ separados, tal que [k,c] es el mínimo ancestro común propio de $[k_i,c_i]$,$[k_j,c_j]$. 
  \end{itemize}
\end{itemize}

 
Con estas definiciones en mente, estamos en condiciones de explicar como utilizar el árbol de componentes para calcular Watershed Topológico.

Sea  $(E,\Gamma,F)$  un grafo, sea $p \in E$. Denotamos como $V(p) = \{[\overline{F}(q),C(q)], q \in \Gamma-(p)\}$. Entonces p tiene las siguientes propiedades:
\begin{itemize}
  \item Si V(p) $\neq \emptyset$ y V(p) no tiene highest fork en $T(\overline{F})$, entonces p será W-destructible para todos los valores $k: w \leq k \leq F(p)$, y no será W-destructible para valor w - 1, donde w es el mínimo nivel de V(p).
  \item Si V(p) $\neq \emptyset$ y V(p) tiene highest fork en $T(\overline{F})$ con una altura $w \leq$ F(p), entonces p será W-destructible para todos los valores $k: w \leq k \leq F(p)$, y no será W-destructible para w - 1.
\end{itemize}
  
Acabamos de ver cómo utilizar el árbol de componentes para determinar a qué valor debemos disminuir un punto W-destructible. Ahora resta ver cómo evitar seleccionar el mismo punto más de una vez.

En [1] se demuestra que seleccionando los puntos de modo de procesar en primera instancia aquellos que bajarán su nivel a un valor menor, no se seleccionará de nuevo el mismo punto. Esta técnica comenzará disminuyendo el valor de los píxeles adyacentes a los mínimos (los cuales obviamente NO serán seleccionados dos veces) y disminuirá todos aquiellos pixeles que formarán parte de los mínimos del Watershed Topológico de la imagn, y luego disminuirá aquellos pixeles W-destructibles que no formarán parte de los mínimos de la imagen resultante.

  
\section{Implementación}

<Aquí viene una imagen del pseudo código, y una explicación linea a linea>

\end{document}